"""
Pydantic models for match data.

A match represents a pair of videos (left/right) with their assigned lens profiles.
This is the first step in the video stitching pipeline.
"""

from typing import Optional, Dict, Any, List, Literal
from pydantic import BaseModel, Field, field_validator
from datetime import datetime, timezone


# Processing status enum
MatchStatus = Literal["pending", "transcoding", "calibrating", "ready", "warning", "error"]

# Processing step enum
ProcessingStep = Literal[
    "initializing",
    "transcoding",
    "awaiting_frames",  # Video ready, waiting for frontend to extract/warp frames
    "extracting_frame",
    "feature_matching",
    "optimizing",
    "generating_uniforms",
    "complete",
]


class QualitySettings(BaseModel):
    """Video quality settings for transcoding. Simplified - presets handled in frontend."""

    preset: Literal["720p", "1080p", "1440p", "custom"] = Field(
        default="1080p", description="Quality preset (for display only)"
    )
    bitrate: str = Field(default="50M", description="Target bitrate (e.g., '30M', '50M')")
    speed_preset: Literal["ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower"] = Field(
        default="medium", description="FFmpeg speed preset"
    )
    resolution: Literal["720p", "1080p", "1440p", "4k"] = Field(
        default="1080p", description="Output resolution (2x stacked)"
    )
    use_gpu_decode: bool = Field(default=True, description="Use GPU hardware acceleration for video decoding")


class ProcessingInfo(BaseModel):
    """Processing state and progress information."""

    status: MatchStatus = Field(default="pending", description="Processing status")
    step: Optional[ProcessingStep] = Field(None, description="Current processing step")
    message: Optional[str] = Field(None, description="Detailed processing progress message")
    started_at: Optional[str] = Field(None, description="Processing start timestamp")
    completed_at: Optional[str] = Field(None, description="Processing completion timestamp")
    error_code: Optional[str] = Field(None, description="Error code if processing failed")
    error_message: Optional[str] = Field(None, description="User-friendly error message")


class TranscodeMetrics(BaseModel):
    """Transcoding performance metrics and audio sync."""

    fps: Optional[float] = Field(None, description="Average transcoding FPS")
    speed: Optional[str] = Field(None, description="Transcoding speed (e.g., '14.2x')")
    progress: Optional[float] = Field(None, description="Progress percentage (0-100)")
    current_time: Optional[float] = Field(None, description="Current time position in seconds")
    total_duration: Optional[float] = Field(None, description="Total video duration in seconds")
    offset_seconds: Optional[float] = Field(None, description="Audio sync offset in seconds")


class VideoInput(BaseModel):
    """Video file input with lens profile."""

    path: str = Field(..., description="Local filesystem path to video file")
    profile_id: Optional[str] = Field(None, description="Lens profile ID assigned to this video")

    @field_validator("path")
    @classmethod
    def validate_path(cls, v: str) -> str:
        """Validate that path is not empty."""
        if not v or not v.strip():
            raise ValueError("Video path cannot be empty")
        return v.strip()


class MatchModel(BaseModel):
    """
    Match model representing a video match for stitching.

    Attributes:
        id: Unique match identifier
        name: User-friendly match name
        left_videos: List of left camera video inputs
        right_videos: List of right camera video inputs
        src: Optional output video URL (generated by backend processing)
        params: Calibration parameters
        left_uniforms: Left camera uniforms
        right_uniforms: Right camera uniforms
        created_at: Match creation timestamp
        metadata: Additional metadata
        status: Processing status
        error_code: Error code if status is error
        error_message: User-friendly error message
        processing_started_at: Timestamp when processing started
        processing_completed_at: Timestamp when processing completed
        processing_step: Current processing step
    """

    # Core match data
    id: str = Field(..., description="Unique match identifier")
    name: Optional[str] = Field(None, description="Match display name")
    left_videos: List[VideoInput] = Field(default_factory=list, description="Left camera video inputs")
    right_videos: List[VideoInput] = Field(default_factory=list, description="Right camera video inputs")
    src: Optional[str] = Field(None, description="Output video URL (generated after processing)")
    params: Optional[Dict[str, float]] = Field(
        None, description="Camera calibration parameters (generated by processing)"
    )
    left_uniforms: Optional[Dict[str, Any]] = Field(None, description="Left camera uniforms from lens profile")
    right_uniforms: Optional[Dict[str, Any]] = Field(None, description="Right camera uniforms from lens profile")
    created_at: str = Field(
        default_factory=lambda: datetime.now(timezone.utc).isoformat(), description="Creation timestamp"
    )
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    viewed: bool = Field(default=False, description="Whether the match has been viewed in the viewer")
    num_matches: Optional[int] = Field(None, description="Number of feature matches found")
    confidence: Optional[float] = Field(None, description="Match confidence score")

    # Nested groups
    processing: ProcessingInfo = Field(default_factory=ProcessingInfo, description="Processing state and progress")
    transcode: Optional[TranscodeMetrics] = Field(None, description="Transcoding metrics")
    quality_settings: Optional[QualitySettings] = Field(None, description="Video quality settings for transcoding")

    @field_validator("id")
    @classmethod
    def validate_id(cls, v: str) -> str:
        """Validate that ID is not empty and contains only valid characters."""
        if not v or not v.strip():
            raise ValueError("Match ID cannot be empty")

        # Allow alphanumeric, hyphens, underscores
        cleaned = v.strip()
        if not all(c.isalnum() or c in ('-', '_') for c in cleaned):
            raise ValueError("Match ID can only contain alphanumeric characters, hyphens, and underscores")

        return cleaned

    @field_validator("name")
    @classmethod
    def validate_name_or_label(cls, v: Optional[str]) -> Optional[str]:
        """Validate that name/label is not empty if provided."""
        if v is not None and not v.strip():
            raise ValueError("Name/label cannot be empty if provided")
        return v.strip() if v else v

    def update_processing(self, **kwargs) -> "MatchModel":
        """Update processing fields."""
        if not self.processing:
            self.processing = ProcessingInfo()

        for key, value in kwargs.items():
            if value is not None and hasattr(self.processing, key):
                setattr(self.processing, key, value)

        return self

    def update_transcode(self, **kwargs) -> "MatchModel":
        """Update transcode fields."""
        if not self.transcode:
            self.transcode = TranscodeMetrics()

        for key, value in kwargs.items():
            if value is not None and hasattr(self.transcode, key):
                setattr(self.transcode, key, value)

        return self

    def get_status(self) -> str:
        """Get processing status, defaults to 'pending'."""
        return self.processing.status if self.processing else "pending"

    def get_transcode_fps(self) -> Optional[float]:
        """Get transcode FPS."""
        return self.transcode.fps if self.transcode else None
