"""
Pydantic models for match data.

A match represents a pair of videos (left/right) with their assigned lens profiles.
This is the first step in the video stitching pipeline.
"""

from typing import Optional, Dict, Any, List, Literal
from pydantic import BaseModel, Field, field_validator
from datetime import datetime, timezone


# Processing status enum
MatchStatus = Literal["pending", "transcoding", "calibrating", "ready", "error"]

# Processing step enum
ProcessingStep = Literal[
    "initializing",
    "transcoding",
    "awaiting_frames",  # Video ready, waiting for frontend to extract/warp frames
    "extracting_frame",
    "feature_matching",
    "optimizing",
    "position_optimization",  # Keep for backwards compatibility
    "generating_uniforms",
    "complete",
]


class VideoInput(BaseModel):
    """Video file input with lens profile."""

    path: str = Field(..., description="Local filesystem path to video file")
    profile_id: Optional[str] = Field(None, description="Lens profile ID assigned to this video")

    @field_validator("path")
    @classmethod
    def validate_path(cls, v: str) -> str:
        """Validate that path is not empty."""
        if not v or not v.strip():
            raise ValueError("Video path cannot be empty")
        return v.strip()


class MatchModel(BaseModel):
    """
    Match model representing a video match for stitching.

    Attributes:
        id: Unique match identifier
        name: User-friendly match name (or label for legacy)
        left_videos: List of left camera video inputs
        right_videos: List of right camera video inputs
        src: Optional output video URL (generated by backend processing)
        params: Calibration parameters
        left_uniforms: Left camera uniforms
        right_uniforms: Right camera uniforms
        created_at: Match creation timestamp
        metadata: Additional metadata
        status: Processing status
        error_code: Error code if status is error
        error_message: User-friendly error message
        processing_started_at: Timestamp when processing started
        processing_completed_at: Timestamp when processing completed
        processing_step: Current processing step
    """

    id: str = Field(..., description="Unique match identifier")
    name: Optional[str] = Field(None, description="Match display name")
    label: Optional[str] = Field(None, description="Legacy label field")
    left_videos: List[VideoInput] = Field(default_factory=list, description="Left camera video inputs")
    right_videos: List[VideoInput] = Field(default_factory=list, description="Right camera video inputs")
    src: Optional[str] = Field(None, description="Output video URL (generated after processing)")
    params: Optional[Dict[str, float]] = Field(
        None, description="Camera calibration parameters (generated by processing)"
    )
    left_uniforms: Optional[Dict[str, Any]] = Field(None, description="Left camera uniforms from lens profile")
    right_uniforms: Optional[Dict[str, Any]] = Field(None, description="Right camera uniforms from lens profile")
    created_at: str = Field(
        default_factory=lambda: datetime.now(timezone.utc).isoformat(), description="Creation timestamp"
    )
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")

    # Processing fields
    status: MatchStatus = Field(default="pending", description="Processing status")
    error_code: Optional[str] = Field(None, description="Error code if processing failed")
    error_message: Optional[str] = Field(None, description="User-friendly error message")
    processing_started_at: Optional[str] = Field(None, description="Processing start timestamp")
    processing_completed_at: Optional[str] = Field(None, description="Processing completion timestamp")
    processing_step: Optional[ProcessingStep] = Field(None, description="Current processing step")
    processing_message: Optional[str] = Field(None, description="Detailed processing progress message")
    viewed: bool = Field(default=False, description="Whether the match has been viewed in the viewer")

    @field_validator("id")
    @classmethod
    def validate_id(cls, v: str) -> str:
        """Validate that ID is not empty and contains only valid characters."""
        if not v or not v.strip():
            raise ValueError("Match ID cannot be empty")

        # Allow alphanumeric, hyphens, underscores
        cleaned = v.strip()
        if not all(c.isalnum() or c in ('-', '_') for c in cleaned):
            raise ValueError("Match ID can only contain alphanumeric characters, hyphens, and underscores")

        return cleaned

    @field_validator("name", "label")
    @classmethod
    def validate_name_or_label(cls, v: Optional[str]) -> Optional[str]:
        """Validate that name/label is not empty if provided."""
        if v is not None and not v.strip():
            raise ValueError("Name/label cannot be empty if provided")
        return v.strip() if v else v
